<!DOCTYPE html>
<html lang="en">

<style>
    div#minimapcontainer {}

    canvas#minimap {
        position: absolute;
    }

    canvas#minimapobjects {
        position: absolute;
    }
</style>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <div id="minimapcontainer">
        <canvas id="minimap"></canvas>
        <canvas id="minimapobjects"></canvas>
    </div>
    <script type="text/javascript">

        let $ = function (id) { return document.getElementById(id); };
        let dc = function (tag) { return document.createElement(tag); };

        let map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 3, 0, 3, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 1, 1, 1],
            [1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
            [1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 4, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 4, 3, 3, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];


        let mapWidth = 0;
        let mapHeight = 0;
        let miniMapScale = 8;

        let screenWidth = 320;


        let player = {
            x: 16,
            y: 10,
            dir: 0,
            rot: 0,
            speed: 0,
            moveSpeed: 0.18,
            rotSpeed: 6
        }

        let stripWidth = 4;
        let fov = 60 * Math.PI / 180;

        let numRays = Math.ceil(screenWidth / stripWidth);
        let fovHalf = fov / 2;

        let viewDist = (screenWidth / 2) / Math.tan((fov / 2));

        let twoPI = Math.PI * 2;


        init = () => {

            mapWidth = map[0].length;
            mapHeight = map.length;
            bindKeys();
            drawMiniMap();
            gameCycle();
        }

        bindKeys = () => {
            document.onkeydown = (e) => {
                e = e || window.event;

                switch (e.keyCode) {

                    case 38:
                        player.speed = 1;
                        break;

                    case 40:
                        player.speed = -1;
                        break;

                    case 37:
                        player.dir = -1;
                        break;

                    case 39:
                        player.dir = 1;
                        break;
                }
            }

            document.onkeyup = function (e) {
                e = e || window.event;

                switch (e.keyCode) {
                    case 38:
                    case 40:
                        player.speed = 0;	// stop the player movement when up/down key is released
                        break;
                    case 37:
                    case 39:
                        player.dir = 0;
                        break;
                }
            }
        }

        /*Raycasting*/

        drawRay = (rayX, rayY) => {
            let miniMapObjects = $("minimapobjects");
            let objectCtx = miniMapObjects.getContext("2d");

            objectCtx.strokeStyle = "rgba(0,100,0,0.3)";
            objectCtx.lineWidth = 0.5;
            objectCtx.beginPath();
            objectCtx.moveTo(player.x * miniMapScale, player.y * miniMapScale);
            objectCtx.lineTo(
                rayX * miniMapScale,
                rayY * miniMapScale
            );

            objectCtx.closePath();
            objectCtx.stroke();
        }

        castSingleRay = (rayAngle, stripIdx) => {
            rayAngle %= twoPI;
            if (rayAngle < 0) rayAngle += twoPI;

            let right = (rayAngle > twoPI * 0.75 || rayAngle < twoPI * 0.25);
            let up = (rayAngle < 0 || rayAngle > Math.PI);

            let angleSin = Math.sin(rayAngle);
            let angleCos = Math.cos(rayAngle);

            let dist = 0;
            let xHit = 0;
            let yHit = 0;

            let textureX;
            let wallX;
            let wallY;

            let slope = angleSin / angleCos;
            let dX = right ? 1 : -1;
            let dY = dX * slope;

            let x = right ? Math.ceil(player.x) : Math.floor(player.x);	// starting horizontal position, at one of the edges of the current map block
            let y = player.y + (x - player.x) * slope;			// starting vertical position. We add the small horizontal step we just made, multiplied by the slope.


            while (x >= 0 && x < mapHeight && y >= 0 && y < mapHeight) {
                let wallX = Math.floor(x + (right ? 0 : -1));
                let wallY = Math.floor(y);

                if (map[wallY][wallX] > 0) {
                    let distX = x - player.x;
                    let distY = y - player.y;
                    dist = distX * distX + distY * distY;

                    textureX = y % 1;
                    if (!right) textureX = 1 - textureX;

                    xHit = x;
                    yHit = y;

                    break;
                }

                x += dX;
                y += dY;
            }

            slope = angleCos / angleSin;
            dY = up ? -1 : 1;
            dX = dY * slope;
            y = up ? Math.floor(player.y) : Math.ceil(player.y);
            x = player.x + (y - player.y) * slope;

            while (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
                let wallY = Math.floor(y + (up ? -1 : 0));
                let wallX = Math.floor(x);
                if (map[wallY][wallX] > 0) {
                    let distX = x - player.x;
                    let distY = y - player.y;
                    let blockDist = distX * distX + distY * distY;
                    if (!dist || blockDist < dist) {
                        dist = blockDist;
                        xHit = x;
                        yHit = y;
                        textureX = x % 1;
                        if (up) textureX = 1 - textureX;
                    }
                    break;
                }
                x += dX;
                y += dY;
            }

            if (dist) {
                drawRay(xHit, yHit);
            }


        }

        castRays = () => {
            let stripIdx = 0;

            for (let i = 0; i < numRays; i++) {
                let rayScreenPos = (-numRays / 2 + i) * stripWidth;
                let rayViewDist = Math.sqrt(rayScreenPos * rayScreenPos + viewDist * viewDist);
                let rayAngle = Math.asin(rayScreenPos / rayViewDist);

                castSingleRay(
                    player.rot + rayAngle, 	// add the players viewing direction to get the angle in world space
                    stripIdx++
                );
            }


        }






        updateMiniMap = () => {
            let miniMap = $("minimap");
            let miniMapObjects = $("minimapobjects");

            let objectCtx = miniMapObjects.getContext("2d");
            objectCtx.clearRect(0, 0, miniMap.width, miniMap.height);

            objectCtx.fillRect(
                player.x * miniMapScale - 2,
                player.y * miniMapScale - 2,
                4,
                4
            );

            objectCtx.beginPath();
            objectCtx.moveTo(player.x * miniMapScale, player.y * miniMapScale);
            objectCtx.lineTo(
                (player.x + Math.cos(player.rot) * 4) * miniMapScale,
                (player.y + Math.sin(player.rot) * 4) * miniMapScale
            );
            objectCtx.closePath();
            objectCtx.stroke();
        }

        gameCycle = () => {
            move();
            castRays();
            updateMiniMap();
            setTimeout(gameCycle, 1000 / 30);
        }

        drawMiniMap = () => {
            // draw the topdown view minimap

            let miniMap = $("minimap");
            let miniMapCtr = $("minimapcontainer");		// the container div element
            let miniMapObjects = $("minimapobjects");

            miniMap.width = mapWidth * miniMapScale;	// resize the internal canvas dimensions 
            miniMap.height = mapHeight * miniMapScale;
            miniMapObjects.width = miniMap.width;
            miniMapObjects.height = miniMap.height;

            let w = (mapWidth * miniMapScale) + "px" 	// minimap CSS dimensions
            let h = (mapHeight * miniMapScale) + "px"
            miniMap.style.width = miniMapObjects.style.width = miniMapCtr.style.width = w;
            miniMap.style.height = miniMapObjects.style.height = miniMapCtr.style.height = h;


            let ctx = miniMap.getContext("2d");

            // loop through all blocks on the map
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {

                    let wall = map[y][x];

                    if (wall > 0) { // if there is a wall block at this (x,y) ...

                        ctx.fillStyle = "rgb(200,200,200)";
                        ctx.fillRect(				// ... then draw a block on the minimap
                            x * miniMapScale,
                            y * miniMapScale,
                            miniMapScale, miniMapScale
                        );

                    }
                }
            }

            updateMiniMap();
        }

        setTimeout(init, 1);

        move = () => {
            let moveStep = player.speed * player.moveSpeed;

            player.rot += player.dir * player.rotSpeed * Math.PI / 180;

            let newX = player.x + Math.cos(player.rot) * moveStep;	// calculate new player position with simple trigonometry
            let newY = player.y + Math.sin(player.rot) * moveStep;

            if (isBlocking(newX, newY)) {
                return;
            }

            player.x = newX; // set new position
            player.y = newY;
        }

        isBlocking = (x, y) => {

            if (y < 0 || y > mapHeight || x < 0 || x > mapWidth)
                return true;

            return (map[Math.floor(y)][Math.floor(x)] != 0);
        }

    </script>


</body>

</html>